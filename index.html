<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Who Wants to Be a Trivial</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: 'Inter', sans-serif;
            color: white;
            overflow: hidden;
            background-color: #502b00d5;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
        }
        #ui-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1rem;
        }
        .glass-panel {
            background: rgba(35, 35, 45, 0.6);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2rem;
            width: clamp(600px, 80vw, 800px);
            text-align: center;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .glass-panel h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 0;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .glass-panel p {
            font-size: 1.2rem;
            line-height: 1.6;
            opacity: 0.9;
        }
        .answer-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .answer-button {
            background: rgba(50, 50, 70, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 1rem;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
            text-align: left;
        }
        .answer-button:hover {
            transform: scale(1.05);
            background: rgba(70, 70, 100, 0.8);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }
        .correct {
            background: rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7);
            animation: pulse 1s infinite;
        }
        .incorrect {
            background: rgba(255, 0, 0, 0.5);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.7);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        @keyframes slideIn {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .question-enter {
            animation: slideIn 0.5s ease forwards;
        }
        #file-upload-container {
            margin: 1rem 0;
            display: none;
        }
        #toggle-upload {
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0);
            border: 1px solid rgba(94, 94, 94, 0);
            border-radius: 0%;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: 0.5s linear;
        }
        #toggle-upload:hover {
            border-radius: 50%;
            transform: scale(1.1);
            background: rgba(37, 60, 192, 0.8);
        }
        #file-input-button {
            background: rgba(50, 50, 70, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 0.8rem 1.5rem;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.3s ease, background 0.3s ease;
        }
        #file-input-button:hover {
            transform: scale(1.05);
            background: rgba(70, 70, 100, 0.8);
        }
        #score {
            font-size: 1.5rem;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        #fallback {
            display: none;
            text-align: center;
            padding: 2em;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #111;
        }
    </style>
</head>
<body>
    <canvas id="webgpu-canvas"></canvas>
    <div id="ui-container">
        <div class="glass-panel">
            <h1>Who Wants to Be a Trivial</h1>
            <center><button id="toggle-upload"></button></center>
            <div id="file-upload-container">
                <input type="file" id="file-input" accept=".csv" style="display: none;">
                <button id="file-input-button">Choose File</button>
                <div id="colorPickerContainer" style="text-align: center;">
                    <input type="color" id="colorPicker" value="#000000" style="width:40px;height:40px;border:none;cursor:pointer; border-radius: 100%; background-color: #11111100;">
                    <div>
                        <input type="range" id="alphaSlider" min="0" max="1" step="0.01" value="0.5" style="width:150px;margin-top:10px;">
                        <span id="alphaValue">1.0</span>
                    </div>
                </div>
                <script>
                    function updateBackground() {
                        const colorPicker = document.getElementById('colorPicker');
                        const alphaSlider = document.getElementById('alphaSlider');
                        const alphaValue = document.getElementById('alphaValue');
                        const color = colorPicker.value;
                        const alpha = alphaSlider.value;
                        const r = parseInt(color.slice(1, 3), 16);
                        const g = parseInt(color.slice(3, 5), 16);
                        const b = parseInt(color.slice(5, 7), 16);
                        document.body.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        alphaValue.textContent = alpha;
                    }

                    const colorPicker = document.getElementById('colorPicker');
                    const alphaSlider = document.getElementById('alphaSlider');
                    colorPicker.addEventListener('input', updateBackground);
                    alphaSlider.addEventListener('input', updateBackground);

                    // Initial background update
                    updateBackground();
                </script>
            </div>
            <p id="score">Score: 0</p>
            <p id="question"></p>
            <div class="answer-grid" id="answers"></div>
        </div>
    </div>
    <div id="fallback">
        <div>
            <h1>WebGPU Not Supported</h1>
            <p>Your browser does not support WebGPU. Please try a modern browser like Chrome or Edge.</p>
        </div>
    </div>

    <script type="module">
        async function main() {
            // WebGPU Setup (unchanged from provided code)
            if (!navigator.gpu) {
                document.getElementById('ui-container').style.display = 'none';
                document.getElementById('fallback').style.display = 'flex';
                return;
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                document.getElementById('ui-container').style.display = 'none';
                document.getElementById('fallback').style.display = 'flex';
                return;
            }
            const device = await adapter.requestDevice();
            const canvas = document.getElementById('webgpu-canvas');
            const context = canvas.getContext('webgpu');
            const devicePixelRatio = window.devicePixelRatio || 1;

            function configureCanvas() {
                canvas.width = canvas.clientWidth * devicePixelRatio;
                canvas.height = canvas.clientHeight * devicePixelRatio;
                context.configure({
                    device,
                    format: presentationFormat,
                    alphaMode: 'premultiplied',
                });
            }

            const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            configureCanvas();

            const shaderModule = device.createShaderModule({
                code: `
                    struct Uniforms {
                        time: f32,
                        @align(8) resolution: vec2<f32>,
                    };
                    @group(0) @binding(0) var<uniform> uniforms: Uniforms;
                    @vertex
                    fn vs_main(@builtin(vertex_index) in_vertex_index: u32) -> @builtin(position) vec4<f32> {
                        let x = f32(i32(in_vertex_index) % 2) * 2.0 - 1.0;
                        let y = f32(i32(in_vertex_index) / 2) * 2.0 - 1.0;
                        return vec4<f32>(x, -y, 0.0, 1.0);
                    }
                    @fragment
                    fn fs_main(@builtin(position) frag_coord: vec4<f32>) -> @location(0) vec4<f32> {
                        let uv = frag_coord.xy / uniforms.resolution.xy;
                        let time = uniforms.time * 0.1;
                        var color = vec3<f32>(0.0);
                        let color1 = vec3<f32>(sin(uv.x * 5.0 + time), sin(uv.y * 5.0 + time), sin((uv.x + uv.y) * 5.0 + time));
                        let color2 = vec3<f32>(sin(uv.x * 10.0 - time), sin(uv.y * 10.0 - time), sin((uv.x + uv.y) * 10.0 - time));
                        let mix_factor = (sin(time + uv.x * 2.0) + 1.0) * 0.5;
                        color = mix(color1, color2, mix_factor);
                        for (var i: i32 = 0; i < 5; i = i + 1) {
                            let fi = f32(i);
                            let circle_pos = vec2<f32>(sin(time * (0.5 + fi * 0.1)), cos(time * (0.5 + fi * 0.1))) * 0.5 + 0.5;
                            let dist = distance(uv, circle_pos);
                            color += vec3<f32>(0.1, 0.2, 0.3) / (dist * 20.0);
                        }
                        return vec4<f32>(color * 0.5 + 0.5, 1.0);
                    }
                `,
            });

            const pipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module: shaderModule, entryPoint: 'vs_main' },
                fragment: { module: shaderModule, entryPoint: 'fs_main', targets: [{ format: presentationFormat }] },
                primitive: { topology: 'triangle-strip' },
            });

            const uniformBufferSize = 16;
            const uniformBuffer = device.createBuffer({
                size: uniformBufferSize,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            const uniformData = new Float32Array(4);
            const bindGroup = device.createBindGroup({
                layout: pipeline.getBindGroupLayout(0),
                entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
            });

            window.addEventListener('resize', configureCanvas);

            function frame() {
                if (!device) return;
                uniformData[0] = performance.now() / 1000;
                uniformData[2] = canvas.width;
                uniformData[3] = canvas.height;
                device.queue.writeBuffer(uniformBuffer, 0, uniformData);
                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();
                const renderPassDescriptor = {
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                };
                const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
                passEncoder.setPipeline(pipeline);
                passEncoder.setBindGroup(0, bindGroup);
                passEncoder.draw(4);
                passEncoder.end();
                device.queue.submit([commandEncoder.finish()]);
                requestAnimationFrame(frame);
            }
            requestAnimationFrame(frame);

            // Game Logic
            let questions = [];
            let currentQuestionIndex = 0;
            let score = 0;
            let questionOrder = [];
            let currentWave = 1;
            const questionsPerWave = 10;

            // Sound Effects
            const correctSound = new Audio('https://www.soundjay.com/buttons/sounds/button-09.mp3');
            const incorrectSound = new Audio('https://www.soundjay.com/buttons/sounds/button-30.mp3');
            const clickSound = new Audio('https://www.soundjay.com/buttons/sounds/button-16.mp3');

            const fileInput = document.getElementById('file-input');
            const fileInputButton = document.getElementById('file-input-button');
            const toggleUploadButton = document.getElementById('toggle-upload');
            const fileUploadContainer = document.getElementById('file-upload-container');
            const questionElement = document.getElementById('question');
            const answersElement = document.getElementById('answers');
            const scoreElement = document.getElementById('score');

            fileInputButton.addEventListener('click', () => {
                fileInput.click();
            });

            toggleUploadButton.addEventListener('click', () => {
                fileUploadContainer.style.display = fileUploadContainer.style.display === 'none' ? 'block' : 'none';
                toggleUploadButton.textContent = fileUploadContainer.style.display === 'none' ? '' : '';
            });

            fileInput.addEventListener('change', handleFileUpload);

            function handleFileUpload(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const csv = e.target.result;
                        questions = parseCSV(csv);
                        if (questions.length > 0) {
                            // Initialize random question order for first wave
                            questionOrder = shuffleArray([...Array(questions.length).keys()]).slice(0, questionsPerWave);
                            displayQuestion();
                        }
                    };
                    reader.readAsText(file);
                }
            }

            function parseCSV(csv) {
                const lines = csv.trim().split('\n').slice(1).map(line => {
                    // Remove quotes and split by comma
                    const items = line.split(',').map(item => item.trim().replace(/^"|"$/g, ''));
                    return {
                        question: items[0],
                        correctAnswer: items[1],
                        answers: [items[1], items[2], items[3], items[4]]
                    };
                });
                return lines;
            }

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            function displayQuestion() {
                if (currentQuestionIndex >= questionsPerWave) {
                    if (currentWave * questionsPerWave >= questions.length) {
                        questionElement.textContent = `Game Over! Final Score: ${score}`;
                        answersElement.innerHTML = '';
                        return;
                    }
                    currentWave++;
                    currentQuestionIndex = 0;
                    questionOrder = shuffleArray([...Array(questions.length).keys()].filter(i => !questionOrder.includes(i))).slice(0, questionsPerWave);
                    questionElement.textContent = `Wave ${currentWave} - Get ready!`;
                    answersElement.innerHTML = '';
                    setTimeout(displayQuestion, 2000);
                    return;
                }
                const q = questions[questionOrder[currentQuestionIndex]];
                questionElement.textContent = `Wave ${currentWave}: ${q.question}`;
                questionElement.classList.add('question-enter');
                answersElement.innerHTML = '';
                // Randomly assign letters and shuffle answer positions
                const letters = ['A', 'B', 'C', 'D'];
                const shuffledAnswers = shuffleArray([...q.answers]);
                const answerOrder = shuffleArray([0, 1, 2, 3]);
                const answerButtons = [];
                
                shuffledAnswers.forEach((answer, index) => {
                    const button = document.createElement('button');
                    button.classList.add('answer-button');
                    button.textContent = `${letters[index]}. ${answer}`;
                    button.dataset.answer = answer;
                    button.addEventListener('click', () => {
                        clickSound.play().catch(err => console.error('Sound error:', err));
                        handleAnswer(answer, button);
                    });
                    answerButtons.push({ button, order: answerOrder[index] });
                });

                // Place buttons in random grid positions
                answerButtons.sort((a, b) => a.order - b.order).forEach(({ button }) => {
                    answersElement.appendChild(button);
                    setTimeout(() => button.classList.add('question-enter'), 100);
                });
            }

            function handleAnswer(selectedAnswer, button) {
                const q = questions[questionOrder[currentQuestionIndex]];
                const buttons = answersElement.getElementsByTagName('button');
                for (let btn of buttons) {
                    btn.disabled = true;
                    if (btn.dataset.answer === q.correctAnswer) {
                        btn.classList.add('correct');
                    } else if (btn === button) {
                        btn.classList.add('incorrect');
                    }
                }
                if (selectedAnswer === q.correctAnswer) {
                    score += 1;
                    scoreElement.textContent = `Score: ${score}`;
                    correctSound.play().catch(err => console.error('Sound error:', err));
                } else {
                    incorrectSound.play().catch(err => console.error('Sound error:', err));
                }
                setTimeout(() => {
                    questionElement.classList.remove('question-enter');
                    currentQuestionIndex++;
                    displayQuestion();
                }, 2000);
            }
        }

        main().catch(err => {
            console.error(err);
            document.getElementById('ui-container').style.display = 'none';
            document.getElementById('fallback').style.display = 'flex';
        });
    </script>
</body>
</html>
